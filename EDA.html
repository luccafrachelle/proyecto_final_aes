<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.552">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Martín Grau Pérez">
<meta name="dcterms.date" content="2024-11-10">

<title>Avance</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="EDA_files/libs/clipboard/clipboard.min.js"></script>
<script src="EDA_files/libs/quarto-html/quarto.js"></script>
<script src="EDA_files/libs/quarto-html/popper.min.js"></script>
<script src="EDA_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="EDA_files/libs/quarto-html/anchor.min.js"></script>
<link href="EDA_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="EDA_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="EDA_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="EDA_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="EDA_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Avance</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Martín Grau Pérez </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">November 10, 2024</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="resumen-de-la-base" class="level2">
<h2 class="anchored" data-anchor-id="resumen-de-la-base">Resumen de la base</h2>
<section id="eventos" class="level3">
<h3 class="anchored" data-anchor-id="eventos">Eventos</h3>
<p>Las bases de datos corresponden a los datos de <em>eventing</em> proporcionados por la empresa <em>StatsBomb</em>, especializada en la recolección y análisis de datos en el mundo del fútbol, de cada uno de los partidos del Mundial masculino disputado en Catar en 2022 y del Mundial femenino disputado en Australia y Nueva Zelanda en 2023 (64 partidos). Dicha base está compuesta por los distintos eventos que se realizaron en el transcurso de cada encuentro y variables asociadas a cada tipo de evento según corresponda (184 variables y 459967 observaciones entre los 2 mundiales). Se considera un evento cada una de las acciones realizadas ya sea por los jugadores (pases, tiros al arco, atajadas, regates, traslados de balón, …) así como del resto de los actores de un partido (cambios, tarjetas, inicio/final de partido, entre otras). Las posesiones están compuestas por varios de estos tipos de eventos. En este caso, la base de Statsbomb cuenta con 33 eventos distintos, los cuales se detallan en la tabla a continuación</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>             eventos
1        Starting XI
2         Half Start
3               Pass
4      Ball Receipt*
5              Carry
6           Pressure
7          Clearance
8      Ball Recovery
9       Dispossessed
10              Duel
11    Foul Committed
12          Foul Won
13              Shot
14             Block
15       Goal Keeper
16   Injury Stoppage
17 Referee Ball-Drop
18      Interception
19        Miscontrol
20     Dribbled Past
21           Dribble
22      Substitution
23          Half End
24    Tactical Shift
25            Shield
26             50/50
27             Error
28     Bad Behaviour
29        Player Off
30         Player On
31           Offside
32  Own Goal Against
33      Own Goal For</code></pre>
</div>
</div>
<p>Algunos de estos eventos no refieren especificamente a situaciones de juego tales como incios y finales de partidos, sustituciones de jugadores, formaciones iniciales, tarjetas mostradas por el juez, cambios tácticos, sueltas neutrales de balón y pausas en el partido ya sea por lesión u otra situación excepcional. Estos eventos no serán tenidos en cuenta en el análisis ya se considera que no aportan nada desde el punto de vista del juego y de las posesiones dentro del mismo. ASIMISMO, SI BIEN REFIEREN A ACCIONES DE JUEGO, TAMBIÉN SE EXCLUYEN OTROS EVENTOS TALES COMO SHIELD, MISCONTROL. Lo mismo haremos con los registros de las tandas de penales (período 5 en la base) que serán excluidos del análisis.</p>
<p>En ese sentido se trabajará con las acciones de juego que involucren la pelota o la disputa de ésta. Mayoritariamente tenemos pases pero también se registran traslados con pelota controlada (<em>Carry</em>), recepción de balón (<em>Ball Receipt</em>), acciones defensivas de presión hacia un rival (<em>Pressure</em>), recuperaciones de pelota (<em>Ball Recovery</em>), duelos (<em>Duel</em>), despejes (<em>Clearance</em>), tiros al arco (<em>Shot</em>), regates (<em>Dribble</em>), atajadas(<em>Goal Keeper</em>), entre otros.</p>
<p>Luego de los remates al arco (que determinan los resultados directamente), los pases son el aspecto fundamental de la forma de juego de los equipos por lo que es esperable encontrar que éstos representen la mayor cantidad de registros (30%) y los eventos predominantes en cada posesión (1070 pases en promedio por partido y 6.2 por posesión) independientemente de que estos hayan sido exitosos o no. Los eventos de tipo pases tienen asociados otro tipo de eventos que son los <em>Ball Receipt</em> que por lo general se dan cuando los pases efectivamente llegaron a destino, lo único qué nos dice las coordenadas de la cancha dónde se recibieron los distintos pases. VER QUÉ HACER CON ESTOS TIPOS DE EVENTOS. LOS SACAMOS? HAY BALL RECEIPT QUE NO PROVENGAN DE PASES? QUÉ SON? ????</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="EDA_files/figure-html/unnamed-chunk-1-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="EDA_files/figure-html/unnamed-chunk-1-2.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="variables-a-utilizar" class="level3">
<h3 class="anchored" data-anchor-id="variables-a-utilizar">Variables a utilizar</h3>
<p>Además de la variable ya mencionada respecto a qué tipo de acción se da en cada jugada tenemos otros tipos de variables. Por una parte, tenemos algunas relativas a cada acción (evento de juego): cuándo y dónde se realiza, qué equipo (y qué jugador) lo realiza, qué equipo tiene la posesión y a qué tipo de secuencia refiere (<em>play_pattern.name</em>). Más concretamente, cada acción forma parte de una posesión dentro de cada uno de los 64 partidos a analizar. Estas posesiones son las que queremos estudiar y se definen como los períodos de tiempo en el que un equipo logra establecer el control de la pelota hasta que el rival la recupera y logra asesgurarla. Por ejemplo, puede suceder que haya secuencias en las que un equipo realice acciones dentro de posesiones del equipo rival. Esto se debe a que con esas acciones no logra asegurar la posesión por lo que el identificador correspondiente permanece incambiado. En esta primera instancia del análisis no se tendrán en cuenta este tipo de posesiones, se trabajará únicamente con aquellas en las cuales sólo el equipo <em>dueño</em> de esa secuencia realiza las acciones. También puede ocurrir que si bien un equipo no pierde el control de la pelota, el contador de la posesión se reinicie ya que cuando la pelota sale de la cancha, automáticamente se genera una nueva secuencia independientemente del equipo que reanude el juego.</p>
<p>Por otra parte tenemos distintas características de los distintos tipos de evento según corresponda tales como su éxito o no, los distintos tipos de acciones, distancia, entre otras.</p>
<p>En este contexto se buscará estudiar las distintas secuencias de los equipos en cuanto tienen la posesión a su favor (<em>possession</em>). En ese sentido, tomando en cuenta ambas copas del mundo tenemos en promedio un poco más de 177 posesiones por partido para el mundial masculino mientras que un poco menos de 193 para el femenino.</p>
<div class="cell">
<div class="cell-output cell-output-stderr">
<pre><code>`summarise()` has grouped output by 'mundial', 'match_id'. You can override
using the `.groups` argument.</code></pre>
</div>
</div>
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="EDA_files/figure-html/descr%20pases-1.png" class="img-fluid figure-img" width="672"></p>
<figcaption>dispersión posesiones y pases por partido según mundial</figcaption>
</figure>
</div>
</div>
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="EDA_files/figure-html/descr%20pases-2.png" class="img-fluid figure-img" width="672"></p>
<figcaption>dispersión posesiones y pases por partido según mundial</figcaption>
</figure>
</div>
</div>
</div>
<p>Además de las variables contenidas originalmente en la base, se crea una nueva que nos indica el resultado del partido desde el punto de vista del equipo que realiza la acción (no el equipo dueño de la posesión). Es decir, si el equipo va ganando, perdiendo o empatando.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="EDA_files/figure-html/pases%20por%20pos%20y%20por%20eq-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Por lo tanto, nuestra observaciones pasarán a ser las posesiones y no los distintos eventos. A estos efectos, con la información contenida en los datos de eventing de SB se buscará conformar una base que nos permita describir cada una de estas secuencias para su posterior estudio y clasificación. Para ello, en una primera instancia, no se trabajará con todas las posesiones sino que por simplicidad nos quedaremos únicamente con aquellas posesiones en las cuales las acciones en las mismas son realizadas por el equipos poseedor del balón o, en su defecto, que las acciones del rival no involucren directamente la pelota: acciones de presión, faltas cometidas o recibidas, atajadas del golero y/o jugadores dribleados del conjunto que esta defendiendo (<em>Dribbled Past</em>). De esta manera la trayectoria de la pelota se ve únicamente afectada por las acciones realizadas por el equipo que tiene la posesión y no por el rival. Nos quedaremos finalmente con 5269 posesiones a nivel masculino y 4706 del mundial femenino para estudiar la trayectoria de la pelota en estas secuencias a través de sus características para su posterior clasificación.</p>
</section>
</section>
<section id="características-de-las-posesiones" class="level2">
<h2 class="anchored" data-anchor-id="características-de-las-posesiones">Características de las posesiones</h2>
<p>A través de los datos de eventing se generará una nueva base que contenga características de las casi 10000 secuencias a estudiar. La elección de dichas características es un tanto arbitraria pero se entiende que pueden ser de valor o utilidad a la hora de describir o encontrar ciertos patrones o estilos de juego: coordenadas de inicio y fin de la posesión (así como las zonas de inicio y fin), cantidad pases (totales y exitosos), de traslados (totales y exitosos), de tiros y de eventos en general realizados, cantidad de centros, cambios de frente, ingresos al área rival con pelota controlada y pases dentro del área, promedio de avance en el terreno según sea por pases o traslados con pelota controlada, si la jugada es iniciada por el golero, si éste participa o no, si termina en tiro o en gol, o incluso variables del estilo de la velocidad promedio de la posesión cuando los pases y las conducciones con la pelota se realizan hacia adelante.</p>
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="EDA_files/figure-html/correlaciones-1.png" class="img-fluid figure-img" width="672"></p>
<figcaption>Correlaciones de las caracteristicas de las trayectorias</figcaption>
</figure>
</div>
</div>
</div>
<section id="división-en-zonas" class="level3">
<h3 class="anchored" data-anchor-id="división-en-zonas">División en zonas</h3>
<p>También podría ser útil tener en consideración no sólo dónde inició y terminó cada jugada sino que también de alguna manera replicar la trayectoria de la pelota en la secuencia. Para ello, se propone dividir la cancha en zonas y analizar hacia dónde el equipo llevó el balón y por cuántos sectores (zonas) del terreno pasó la pelota en la jugada. Cabe aclarar que para el conteo de zonas se tendrá en cuenta únicamente aquellas zonas dónde se realizaron acciones y no necesariamente por dónde pasó la pelota.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="EDA_files/figure-html/trayy-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Otro aspecto relevante a estudiar de las secuencias es su éxito o no al momento de generar situaciones ventajosas para el equipo. En ese sentido, se crea una métrica que, en una primera instancia y de manera muy poco abarcativa, se definen como <em>exitosas</em> aquellas jugadas en las que se realiza un remate al arco o bien el equipo que tiene la posesión logra sacar una falta o un córner. Se buscará trabajar en esta línea de modo de definir y encontrar qué tipo de jugadas son <em>exitosas</em> más allá de éstas ya mencionadas. A modo de ejemplo, podríamos preguntarnos si luego de recibir un pase de un compañero, un futbolista logra avanzar una cierta distancia con la pelota controlada, no es una situación ventajosa? La posesión sería <em>exitosa</em> en ese caso?</p>
<p>Si quisieramos podríamos ver en detalle cómo se componen las posesiones de modo de ver qué tipo de eventos realizan los equipos y en qué sector del terreno. A los efectos de caracterizar estas posesiones, estos aspectos pueden tener particular relevancia ya que no es lo mismo que las posesiones sean básicamente pases entre compañeros a que sean jugadores aislados que trasladan la pelota sin tantos pases de por medio.</p>
<p>Respecto a la cantidad de zonas no hay particularmente una división <em>óptima</em> ni <em>mejor</em> pero en este caso tenemos 3 divisiones tales como podemos ver en la figura siguiente (el sentido del ataque es de izquierda a derecha). Las división en 8 zonas corresponde al estudio realizado por <strong>Shen, Santo &amp; Akande</strong> en el cual a través del estudio de los <em>flow-motifs</em> proponen un análisis del ritmo de juego de las posesiones. Las otras dos maneras de dividir la cancha corresponden a distintas propuestas de distintos analistas de modo de estudiar aspectos del juego.</p>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="EDA_files/figure-html/graf%20zonas-1.png" class="img-fluid figure-img" width="672"></p>
<figcaption>División en zonas de la cancha</figcaption>
</figure>
</div>
</div>
</div>
<p>Asimismo, también podría ser relevante observar cuantas acciones (eventos) se realizan en cada una de estas zonas y no solo si pasan por allí o no de modo de caracterizar aún más los patrones de juego de los equipos. Si tomamos la división en 30 zonas, se encuentra la siguiente posesión del partido de Argengina vs Polonia en la cual se realizaron acciones en 20 zonas (no necesariamente por donde pasó la pelota). Cabe preguntarse si es de interés tomar en cuenta las zonas por donde pasa la trayectoria de la pelota en toda la secuencia.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="EDA_files/figure-html/tray-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>De alguna manera resulta esperable que a mayor duración de la posesión, mayor cantidad de zonas por la que pasa el juego de un equipo. Para ello, analizamos las dispersión de la cantidad de zonas por la que pasa una secuencia en función del tiempo (agrupado en intervalos de 6 segundos) Asimismo, podemos ver puntualmente la dispersión de durante todo el campeonato de las secuencias de Argentina y Francia (los finalistas) y de España y Arabia Saudita, el de mayor tiempo de posesión promedio por partido y el de menor respectivamente.</p>
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="EDA_files/figure-html/graf%20nzonas%20vs%20tiempo%20pos-1.png" class="img-fluid figure-img" width="864"></p>
<figcaption>Dispersión de la cantidad de zonas por posesión según su duración (en segs)</figcaption>
</figure>
</div>
</div>
</div>
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="EDA_files/figure-html/graf%20nzonas%20vs%20tiempo%20pos2-1.png" class="img-fluid figure-img" width="864"></p>
<figcaption>Dispersión de la cantidad de zonas por posesión según su duración (en segs)</figcaption>
</figure>
</div>
</div>
</div>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="EDA_files/figure-html/gr-1.png" class="img-fluid figure-img" width="864"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="EDA_files/figure-html/gr-2.png" class="img-fluid figure-img" width="864"></p>
</figure>
</div>
</div>
</div>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>